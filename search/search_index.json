{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Desuko Desuko is an extensible Discord bot, written in Python & Pycord. Features: Hackable : Desuko aims to keep the code clean and intuitive. Extensible : Desuko can be extended by various modules. Fully configurable : Everything can be configured via YAML. Async-friendly : Desuko support asyncronious functions out of the box. Getting started First steps: Installation - Install & run a basic version of Desuko. Configuration - Configurate your Desuko using desuko.yaml . Modules: Hello, Desuko! - \"Hello, World!\" module for Desuko","title":"Home"},{"location":"#desuko","text":"Desuko is an extensible Discord bot, written in Python & Pycord. Features: Hackable : Desuko aims to keep the code clean and intuitive. Extensible : Desuko can be extended by various modules. Fully configurable : Everything can be configured via YAML. Async-friendly : Desuko support asyncronious functions out of the box.","title":"Desuko"},{"location":"#getting-started","text":"First steps: Installation - Install & run a basic version of Desuko. Configuration - Configurate your Desuko using desuko.yaml . Modules: Hello, Desuko! - \"Hello, World!\" module for Desuko","title":"Getting started"},{"location":"docs/getting_started/1_Installation/","text":"Installation 1. Install dependencies: poetry install --no-root --no-dev 2. Complete desuko.yaml with your Discord token: token : YOUR_DISCORD_BOT_TOKEN_HERE 3. (optional) Specify debug guilds to test Desuko faster: debug_guilds : - YOUR_GUILD_ID_HERE 4. Run Desuko as a Python module: python -m desuko","title":"1. Installation"},{"location":"docs/getting_started/1_Installation/#installation","text":"1. Install dependencies: poetry install --no-root --no-dev 2. Complete desuko.yaml with your Discord token: token : YOUR_DISCORD_BOT_TOKEN_HERE 3. (optional) Specify debug guilds to test Desuko faster: debug_guilds : - YOUR_GUILD_ID_HERE 4. Run Desuko as a Python module: python -m desuko","title":"Installation"},{"location":"docs/getting_started/2_Configuration/","text":"Configuration Desuko has pre-defined values to work with. However, it also provides an opportunity to use desuko.yaml for more precise control over things. For now, Desuko handles these options: token ( str ; Required ): Token of your Discord bot debug_guilds ( Iterable[int] ; Optional): Debug guilds (updates slash commands only for specified guilds). Defaults to [] . silence_import_exceptions ( bool ; Optional): Should import failures be handled automatically or leave them as-is? Defaults to True . modules ( dict[str, Any] ; Optional): Modules to extend a Desuko functionality. Keys of this dict are valid import paths, but values can differ. Defaults to {} .","title":"2. Configuration"},{"location":"docs/getting_started/2_Configuration/#configuration","text":"Desuko has pre-defined values to work with. However, it also provides an opportunity to use desuko.yaml for more precise control over things. For now, Desuko handles these options: token ( str ; Required ): Token of your Discord bot debug_guilds ( Iterable[int] ; Optional): Debug guilds (updates slash commands only for specified guilds). Defaults to [] . silence_import_exceptions ( bool ; Optional): Should import failures be handled automatically or leave them as-is? Defaults to True . modules ( dict[str, Any] ; Optional): Modules to extend a Desuko functionality. Keys of this dict are valid import paths, but values can differ. Defaults to {} .","title":"Configuration"},{"location":"docs/modules/Development/HelloDesuko/","text":"Hello, Desuko! Let's make a simple module for Desuko and walk you through it. tutorial.py : __NAME__ = 'tutorial' __DESC__ = '\"Hello, World\" module for Desuko' class Module : def __init__ ( self , loader , slash_group , config ): self . slash_group = slash_group loader . subscribe ( 'desuko.bot.register_slash' , self . register_slash ) def register_slash ( self ): self . slash_group . command ()( self . desuko ) async def desuko ( self , ctx ): await ctx . respond ( 'Hello, Desuko!' ) desuko.yaml : modules : tutorial : Let's explain what we did here step-by-step: On the first lines we provide a name for a Discord slash group and a module description. Having these variables is required . Next, we create a Module class. It represents our main entry. Then we provide an __init__() function to set attributes and bind class functions with handlers. register_slash() registers all our functions as Discord slash commands. Finally, desuko() is an actual Discord command. Its corresponding name will be /tutorial desuko ( /<__NAME__> <func name> ). To connect it with a Desuko bot, simply provide the module name in desuko.yaml . Warning The names of the Module class, __NAME__ and __DESC__ should not change. Loader tries to find exactly these names. Result:","title":"Hello, Desuko!"},{"location":"docs/modules/Development/HelloDesuko/#hello-desuko","text":"Let's make a simple module for Desuko and walk you through it. tutorial.py : __NAME__ = 'tutorial' __DESC__ = '\"Hello, World\" module for Desuko' class Module : def __init__ ( self , loader , slash_group , config ): self . slash_group = slash_group loader . subscribe ( 'desuko.bot.register_slash' , self . register_slash ) def register_slash ( self ): self . slash_group . command ()( self . desuko ) async def desuko ( self , ctx ): await ctx . respond ( 'Hello, Desuko!' ) desuko.yaml : modules : tutorial : Let's explain what we did here step-by-step: On the first lines we provide a name for a Discord slash group and a module description. Having these variables is required . Next, we create a Module class. It represents our main entry. Then we provide an __init__() function to set attributes and bind class functions with handlers. register_slash() registers all our functions as Discord slash commands. Finally, desuko() is an actual Discord command. Its corresponding name will be /tutorial desuko ( /<__NAME__> <func name> ). To connect it with a Desuko bot, simply provide the module name in desuko.yaml . Warning The names of the Module class, __NAME__ and __DESC__ should not change. Loader tries to find exactly these names. Result:","title":"Hello, Desuko!"},{"location":"reference/desuko/","text":"Module desuko Desuko - An extensible Discord bot, written in Python & Pycord. How is it structured? Desuko aims to be modular. It has a base package implemented here and modules to extend its functionality. To make changes into Desuko code, please, make sure that your edits will not break any existing modules. View Source \"\"\"Desuko - An extensible Discord bot, written in Python & Pycord. ## How is it structured? Desuko aims to be modular. It has a base package implemented here and modules to extend its functionality. To make changes into Desuko code, please, make sure that your edits will **not** break any existing modules. \"\"\" from desuko import bot , loader __all__ = ( 'bot' , 'loader' , 'modules' , ) Sub-modules desuko.bot desuko.loader Variables bot loader","title":"Index"},{"location":"reference/desuko/#module-desuko","text":"Desuko - An extensible Discord bot, written in Python & Pycord.","title":"Module desuko"},{"location":"reference/desuko/#how-is-it-structured","text":"Desuko aims to be modular. It has a base package implemented here and modules to extend its functionality. To make changes into Desuko code, please, make sure that your edits will not break any existing modules. View Source \"\"\"Desuko - An extensible Discord bot, written in Python & Pycord. ## How is it structured? Desuko aims to be modular. It has a base package implemented here and modules to extend its functionality. To make changes into Desuko code, please, make sure that your edits will **not** break any existing modules. \"\"\" from desuko import bot , loader __all__ = ( 'bot' , 'loader' , 'modules' , )","title":"How is it structured?"},{"location":"reference/desuko/#sub-modules","text":"desuko.bot desuko.loader","title":"Sub-modules"},{"location":"reference/desuko/#variables","text":"bot loader","title":"Variables"},{"location":"reference/desuko/bot/","text":"Module desuko.bot desuko.bot - Discord bot for Desuko. None View Source \"\"\"desuko.bot - Discord bot for Desuko.\"\"\" import logging import discord from desuko.loader import Loader logger = logging . getLogger ( __name__ ) class DesukoBot : \"\"\"Discord bot class.\"\"\" def __init__ ( self , config : dict , modules : dict ): \"\"\"Initialize a bot. Args: config (dict): Desuko configuration modules (dict): Loaded modules \"\"\" self . config = config self . bot = discord . Bot ( auto_sync_commands = False , debug_guilds = self . config . get ( 'debug_guilds' ), ) self . loader = Loader ( self . bot . create_group , modules ) self . register_slash = self . loader . handler ( self . _register_slash ) self . prepare_bot = self . loader . handler ( self . _prepare_bot ) self . on_ready = self . loader . handler ( self . _on_ready , return_async = True ) self . shutdown = self . loader . handler ( self . _shutdown ) self . loader . init_modules () self . bot . listen ( 'on_ready' )( self . on_ready ) def _register_slash ( self ) -> None : \"\"\"Register slash commands.\"\"\" self . bot . slash_command ( description = 'Say hello!' )( self . hello ) def _prepare_bot ( self ) -> None : \"\"\"Prepare bot before running. This function exists only to handle its subscribers. By using it, we ensure, that Desuko is completely loaded (in terms of modules). \"\"\" def _shutdown ( self ) -> None : \"\"\"Gracefully shutdown the bot. This function exists only to handle its subscribers. By using it, we ensure, that Desuko is closed correctly. \"\"\" logger . warning ( 'Graceful shutdown initiated. Please wait...' ) async def _on_ready ( self ): \"\"\"Desuko is connected to Discord successfully.\"\"\" await self . bot . sync_commands () logger . warning ( 'Ready to go! We have logged in as %s .' , self . bot . user ) async def hello ( self , ctx ): \"\"\"Hello command. Args: ctx (ApplicationContext): Application context \"\"\" embed = discord . Embed ( color = discord . Color . blurple ()) embed . add_field ( name = 'Desuko' , value = 'Hello' , inline = True ) await ctx . send_response ( embed = embed ) def run ( self ) -> None : \"\"\"Run the Discord bot.\"\"\" self . register_slash () self . prepare_bot () self . bot . run ( self . config [ 'token' ]) # TODO: Implement shutdown initiated by modules Variables logger Classes DesukoBot class DesukoBot ( config : dict , modules : dict ) View Source class DesukoBot : \"\"\"Discord bot class.\"\"\" def __init__ ( self , config : dict , modules : dict ): \"\"\"Initialize a bot. Args: config (dict): Desuko configuration modules (dict): Loaded modules \"\"\" self . config = config self . bot = discord . Bot ( auto_sync_commands = False , debug_guilds = self . config . get ( 'debug_guilds' ), ) self . loader = Loader ( self . bot . create_group , modules ) self . register_slash = self . loader . handler ( self . _register_slash ) self . prepare_bot = self . loader . handler ( self . _prepare_bot ) self . on_ready = self . loader . handler ( self . _on_ready , return_async = True ) self . shutdown = self . loader . handler ( self . _shutdown ) self . loader . init_modules () self . bot . listen ( 'on_ready' )( self . on_ready ) def _register_slash ( self ) -> None : \"\"\"Register slash commands.\"\"\" self . bot . slash_command ( description = 'Say hello!' )( self . hello ) def _prepare_bot ( self ) -> None : \"\"\"Prepare bot before running. This function exists only to handle its subscribers. By using it, we ensure, that Desuko is completely loaded (in terms of modules). \"\"\" def _shutdown ( self ) -> None : \"\"\"Gracefully shutdown the bot. This function exists only to handle its subscribers. By using it, we ensure, that Desuko is closed correctly. \"\"\" logger . warning ( 'Graceful shutdown initiated. Please wait...' ) async def _on_ready ( self ): \"\"\"Desuko is connected to Discord successfully.\"\"\" await self . bot . sync_commands () logger . warning ( 'Ready to go! We have logged in as %s .' , self . bot . user ) async def hello ( self , ctx ): \"\"\"Hello command. Args: ctx (ApplicationContext): Application context \"\"\" embed = discord . Embed ( color = discord . Color . blurple ()) embed . add_field ( name = 'Desuko' , value = 'Hello' , inline = True ) await ctx . send_response ( embed = embed ) def run ( self ) -> None : \"\"\"Run the Discord bot.\"\"\" self . register_slash () self . prepare_bot () self . bot . run ( self . config [ 'token' ]) # TODO: Implement shutdown initiated by modules Methods hello def hello ( self , ctx ) Hello command. Parameters: Name Type Description Default ctx ApplicationContext Application context None View Source async def hello(self, ctx): \"\"\"Hello command. Args: ctx (ApplicationContext): Application context \"\"\" embed = discord.Embed(color=discord.Color.blurple()) embed.add_field(name='Desuko', value='Hello', inline=True) await ctx.send_response(embed=embed) run def run ( self ) -> None Run the Discord bot. View Source def run ( self ) -> None: \"\"\"Run the Discord bot.\"\"\" self . register_slash () self . prepare_bot () self . bot . run ( self . config [' token ']) # TODO: Implement shutdown initiated by modules","title":"Bot"},{"location":"reference/desuko/bot/#module-desukobot","text":"desuko.bot - Discord bot for Desuko. None View Source \"\"\"desuko.bot - Discord bot for Desuko.\"\"\" import logging import discord from desuko.loader import Loader logger = logging . getLogger ( __name__ ) class DesukoBot : \"\"\"Discord bot class.\"\"\" def __init__ ( self , config : dict , modules : dict ): \"\"\"Initialize a bot. Args: config (dict): Desuko configuration modules (dict): Loaded modules \"\"\" self . config = config self . bot = discord . Bot ( auto_sync_commands = False , debug_guilds = self . config . get ( 'debug_guilds' ), ) self . loader = Loader ( self . bot . create_group , modules ) self . register_slash = self . loader . handler ( self . _register_slash ) self . prepare_bot = self . loader . handler ( self . _prepare_bot ) self . on_ready = self . loader . handler ( self . _on_ready , return_async = True ) self . shutdown = self . loader . handler ( self . _shutdown ) self . loader . init_modules () self . bot . listen ( 'on_ready' )( self . on_ready ) def _register_slash ( self ) -> None : \"\"\"Register slash commands.\"\"\" self . bot . slash_command ( description = 'Say hello!' )( self . hello ) def _prepare_bot ( self ) -> None : \"\"\"Prepare bot before running. This function exists only to handle its subscribers. By using it, we ensure, that Desuko is completely loaded (in terms of modules). \"\"\" def _shutdown ( self ) -> None : \"\"\"Gracefully shutdown the bot. This function exists only to handle its subscribers. By using it, we ensure, that Desuko is closed correctly. \"\"\" logger . warning ( 'Graceful shutdown initiated. Please wait...' ) async def _on_ready ( self ): \"\"\"Desuko is connected to Discord successfully.\"\"\" await self . bot . sync_commands () logger . warning ( 'Ready to go! We have logged in as %s .' , self . bot . user ) async def hello ( self , ctx ): \"\"\"Hello command. Args: ctx (ApplicationContext): Application context \"\"\" embed = discord . Embed ( color = discord . Color . blurple ()) embed . add_field ( name = 'Desuko' , value = 'Hello' , inline = True ) await ctx . send_response ( embed = embed ) def run ( self ) -> None : \"\"\"Run the Discord bot.\"\"\" self . register_slash () self . prepare_bot () self . bot . run ( self . config [ 'token' ]) # TODO: Implement shutdown initiated by modules","title":"Module desuko.bot"},{"location":"reference/desuko/bot/#variables","text":"logger","title":"Variables"},{"location":"reference/desuko/bot/#classes","text":"","title":"Classes"},{"location":"reference/desuko/bot/#desukobot","text":"class DesukoBot ( config : dict , modules : dict ) View Source class DesukoBot : \"\"\"Discord bot class.\"\"\" def __init__ ( self , config : dict , modules : dict ): \"\"\"Initialize a bot. Args: config (dict): Desuko configuration modules (dict): Loaded modules \"\"\" self . config = config self . bot = discord . Bot ( auto_sync_commands = False , debug_guilds = self . config . get ( 'debug_guilds' ), ) self . loader = Loader ( self . bot . create_group , modules ) self . register_slash = self . loader . handler ( self . _register_slash ) self . prepare_bot = self . loader . handler ( self . _prepare_bot ) self . on_ready = self . loader . handler ( self . _on_ready , return_async = True ) self . shutdown = self . loader . handler ( self . _shutdown ) self . loader . init_modules () self . bot . listen ( 'on_ready' )( self . on_ready ) def _register_slash ( self ) -> None : \"\"\"Register slash commands.\"\"\" self . bot . slash_command ( description = 'Say hello!' )( self . hello ) def _prepare_bot ( self ) -> None : \"\"\"Prepare bot before running. This function exists only to handle its subscribers. By using it, we ensure, that Desuko is completely loaded (in terms of modules). \"\"\" def _shutdown ( self ) -> None : \"\"\"Gracefully shutdown the bot. This function exists only to handle its subscribers. By using it, we ensure, that Desuko is closed correctly. \"\"\" logger . warning ( 'Graceful shutdown initiated. Please wait...' ) async def _on_ready ( self ): \"\"\"Desuko is connected to Discord successfully.\"\"\" await self . bot . sync_commands () logger . warning ( 'Ready to go! We have logged in as %s .' , self . bot . user ) async def hello ( self , ctx ): \"\"\"Hello command. Args: ctx (ApplicationContext): Application context \"\"\" embed = discord . Embed ( color = discord . Color . blurple ()) embed . add_field ( name = 'Desuko' , value = 'Hello' , inline = True ) await ctx . send_response ( embed = embed ) def run ( self ) -> None : \"\"\"Run the Discord bot.\"\"\" self . register_slash () self . prepare_bot () self . bot . run ( self . config [ 'token' ]) # TODO: Implement shutdown initiated by modules","title":"DesukoBot"},{"location":"reference/desuko/bot/#methods","text":"","title":"Methods"},{"location":"reference/desuko/bot/#hello","text":"def hello ( self , ctx ) Hello command. Parameters: Name Type Description Default ctx ApplicationContext Application context None View Source async def hello(self, ctx): \"\"\"Hello command. Args: ctx (ApplicationContext): Application context \"\"\" embed = discord.Embed(color=discord.Color.blurple()) embed.add_field(name='Desuko', value='Hello', inline=True) await ctx.send_response(embed=embed)","title":"hello"},{"location":"reference/desuko/bot/#run","text":"def run ( self ) -> None Run the Discord bot. View Source def run ( self ) -> None: \"\"\"Run the Discord bot.\"\"\" self . register_slash () self . prepare_bot () self . bot . run ( self . config [' token ']) # TODO: Implement shutdown initiated by modules","title":"run"},{"location":"reference/desuko/loader/","text":"Module desuko.loader desuko.loader - Post loader of modules. None View Source \"\"\"desuko.loader - Post loader of modules.\"\"\" import inspect import logging from typing import Callable logger = logging . getLogger ( __name__ ) class Loader : \"\"\"Post loader of Desuko modules.\"\"\" def __init__ ( self , create_group_def : Callable , modules : dict ): \"\"\"Initialize a loader. Args: create_group_def (Callable): `Bot.create_group` function modules (dict): Loaded modules \"\"\" self . __create_group_def = create_group_def self . __modules = modules if modules else {} self . __registered_handlers = {} self . __is_initialized = False self . shared_memory = {} def init_modules ( self ) -> None : \"\"\"Initialize the provided modules.\"\"\" if self . __is_initialized : logger . warning ( 'Attempt to initialize modules twice.' ) return for module_name , module in self . __modules . items (): discord_module_name = '' . join ( i for i in module_name if i . isalpha ())[: 32 ] if not discord_module_name : logger . warning ( ' %s was SKIPPED. (Reason: Invalid __NAME__ value)' , module [ 'import_path' ], ) continue module_cmd_group = self . __create_group_def ( discord_module_name , module [ 'desc' ]) module [ 'class' ]( self , module_cmd_group , module [ 'config' ]) self . __is_initialized = True def handler ( self , func : Callable , return_async = False ) -> Callable : \"\"\"Register a function as a handler. If `bool(return_async) == False`, all subscribers will be treated as non-synchronous. Args: func (Callable): Callable as a Desuko handler return_async (bool): Should the function return an asyncronious Callable Returns: Callable: Registred function \"\"\" if func . __name__ . startswith ( '_' ): func_name = func . __name__ [ 1 :] else : func_name = func . __name__ key = f ' { func . __module__ } . { func_name } ' is_func_async = inspect . iscoroutinefunction ( func ) def handle_subscribers ( * args , ** kwargs ): \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ]: if is_sub_async : logger . warning ( ' %s . %s is an asyncronious function, that was registered as synchronous.' , subscriber . __module__ , subscriber . __name__ , ) subscriber ( * args , ** kwargs ) return result async def async_handle_subscribers ( * args , ** kwargs ): \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" if is_func_async : result = await func ( * args , ** kwargs ) else : result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ]: if is_sub_async : await subscriber ( * args , ** kwargs ) else : subscriber ( * args , ** kwargs ) return result self . __registered_handlers [ key ] = set () logger . info ( 'Handler added: %s ' , key ) return async_handle_subscribers if return_async else handle_subscribers def subscribe ( self , handler : str , func : Callable ) -> None : \"\"\"Return a function to register a subscriber. Args: handler (str): Handler import path func (Callable): Function to add as a subscriber Raises: ValueError: Provided invalid handler \"\"\" try : self . __registered_handlers [ handler ] . add (( func , inspect . iscoroutinefunction ( func ))) except KeyError as exc : raise ValueError ( f ' { exc . args [ 0 ] } is not a valid handler.' ) from exc logger . info ( 'Subscriber added: %s . %s -> %s ' , func . __module__ , func . __name__ , handler ) Variables logger Classes Loader class Loader ( create_group_def : Callable , modules : dict ) View Source class Loader : \"\"\"Post loader of Desuko modules.\"\"\" def __init__ ( self , create_group_def : Callable , modules : dict ) : \"\"\"Initialize a loader. Args: create_group_def (Callable): `Bot.create_group` function modules (dict): Loaded modules \"\"\" self . __create_group_def = create_group_def self . __modules = modules if modules else {} self . __registered_handlers = {} self . __is_initialized = False self . shared_memory = {} def init_modules ( self ) -> None : \"\"\"Initialize the provided modules.\"\"\" if self . __is_initialized : logger . warning ( 'Attempt to initialize modules twice.' ) return for module_name , module in self . __modules . items () : discord_module_name = '' . join ( i for i in module_name if i . isalpha ()) [ :32 ] if not discord_module_name : logger . warning ( '%s was SKIPPED. (Reason: Invalid __NAME__ value)' , module [ 'import_path' ] , ) continue module_cmd_group = self . __create_group_def ( discord_module_name , module [ 'desc' ] ) module [ 'class' ] ( self , module_cmd_group , module [ 'config' ] ) self . __is_initialized = True def handler ( self , func : Callable , return_async = False ) -> Callable : \"\"\"Register a function as a handler. If `bool(return_async) == False`, all subscribers will be treated as non-synchronous. Args: func (Callable): Callable as a Desuko handler return_async (bool): Should the function return an asyncronious Callable Returns: Callable: Registred function \"\"\" if func . __name__ . startswith ( '_' ) : func_name = func . __name__ [ 1: ] else : func_name = func . __name__ key = f '{func.__module__}.{func_name}' is_func_async = inspect . iscoroutinefunction ( func ) def handle_subscribers ( * args , ** kwargs ) : \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ] : if is_sub_async : logger . warning ( '%s.%s is an asyncronious function, that was registered as synchronous.' , subscriber . __module__ , subscriber . __name__ , ) subscriber ( * args , ** kwargs ) return result async def async_handle_subscribers ( * args , ** kwargs ) : \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" if is_func_async : result = await func ( * args , ** kwargs ) else : result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ] : if is_sub_async : await subscriber ( * args , ** kwargs ) else : subscriber ( * args , ** kwargs ) return result self . __registered_handlers [ key ] = set () logger . info ( 'Handler added: %s' , key ) return async_handle_subscribers if return_async else handle_subscribers def subscribe ( self , handler : str , func : Callable ) -> None : \"\"\"Return a function to register a subscriber. Args: handler (str): Handler import path func (Callable): Function to add as a subscriber Raises: ValueError: Provided invalid handler \"\"\" try : self . __registered_handlers [ handler ] . add (( func , inspect . iscoroutinefunction ( func ))) except KeyError as exc : raise ValueError ( f '{exc.args[0]} is not a valid handler.' ) from exc logger . info ( 'Subscriber added: %s.%s -> %s' , func . __module__ , func . __name__ , handler ) Methods handler def handler ( self , func : Callable , return_async = False ) -> Callable Register a function as a handler. If bool(return_async) == False , all subscribers will be treated as non-synchronous. Parameters: Name Type Description Default func Callable Callable as a Desuko handler None return_async bool Should the function return an asyncronious Callable None Returns: Type Description Callable Registred function View Source def handler ( self , func : Callable , return_async = False ) -> Callable : \"\"\"Register a function as a handler. If `bool(return_async) == False`, all subscribers will be treated as non-synchronous. Args: func (Callable): Callable as a Desuko handler return_async (bool): Should the function return an asyncronious Callable Returns: Callable: Registred function \"\"\" if func . __name__ . startswith ( '_' ) : func_name = func . __name__ [ 1: ] else : func_name = func . __name__ key = f '{func.__module__}.{func_name}' is_func_async = inspect . iscoroutinefunction ( func ) def handle_subscribers ( * args , ** kwargs ) : \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ] : if is_sub_async : logger . warning ( '%s.%s is an asyncronious function, that was registered as synchronous.' , subscriber . __module__ , subscriber . __name__ , ) subscriber ( * args , ** kwargs ) return result async def async_handle_subscribers ( * args , ** kwargs ) : \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" if is_func_async : result = await func ( * args , ** kwargs ) else : result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ] : if is_sub_async : await subscriber ( * args , ** kwargs ) else : subscriber ( * args , ** kwargs ) return result self . __registered_handlers [ key ] = set () logger . info ( 'Handler added: %s' , key ) return async_handle_subscribers if return_async else handle_subscribers init_modules def init_modules ( self ) -> None Initialize the provided modules. View Source def init_modules ( self ) -> None : \"\"\"Initialize the provided modules.\"\"\" if self . __is_initialized : logger . warning ( 'Attempt to initialize modules twice.' ) return for module_name , module in self . __modules . items () : discord_module_name = '' . join ( i for i in module_name if i . isalpha ())[ : 32 ] if not discord_module_name : logger . warning ( '%s was SKIPPED. (Reason: Invalid __NAME__ value)' , module [ 'import_path' ], ) continue module_cmd_group = self . __create_group_def ( discord_module_name , module [ 'desc' ]) module [ 'class' ]( self , module_cmd_group , module [ 'config' ]) self . __is_initialized = True subscribe def subscribe ( self , handler : str , func : Callable ) -> None Return a function to register a subscriber. Parameters: Name Type Description Default handler str Handler import path None func Callable Function to add as a subscriber None Raises: Type Description ValueError Provided invalid handler View Source def subscribe ( self , handler : str , func : Callable ) -> None : \"\"\"Return a function to register a subscriber. Args: handler (str): Handler import path func (Callable): Function to add as a subscriber Raises: ValueError: Provided invalid handler \"\"\" try : self . __registered_handlers [ handler ] . add (( func , inspect . iscoroutinefunction ( func ))) except KeyError as exc : raise ValueError ( f ' { exc . args [ 0 ] } is not a valid handler.' ) from exc logger . info ( 'Subscriber added: %s . %s -> %s ' , func . __module__ , func . __name__ , handler )","title":"Loader"},{"location":"reference/desuko/loader/#module-desukoloader","text":"desuko.loader - Post loader of modules. None View Source \"\"\"desuko.loader - Post loader of modules.\"\"\" import inspect import logging from typing import Callable logger = logging . getLogger ( __name__ ) class Loader : \"\"\"Post loader of Desuko modules.\"\"\" def __init__ ( self , create_group_def : Callable , modules : dict ): \"\"\"Initialize a loader. Args: create_group_def (Callable): `Bot.create_group` function modules (dict): Loaded modules \"\"\" self . __create_group_def = create_group_def self . __modules = modules if modules else {} self . __registered_handlers = {} self . __is_initialized = False self . shared_memory = {} def init_modules ( self ) -> None : \"\"\"Initialize the provided modules.\"\"\" if self . __is_initialized : logger . warning ( 'Attempt to initialize modules twice.' ) return for module_name , module in self . __modules . items (): discord_module_name = '' . join ( i for i in module_name if i . isalpha ())[: 32 ] if not discord_module_name : logger . warning ( ' %s was SKIPPED. (Reason: Invalid __NAME__ value)' , module [ 'import_path' ], ) continue module_cmd_group = self . __create_group_def ( discord_module_name , module [ 'desc' ]) module [ 'class' ]( self , module_cmd_group , module [ 'config' ]) self . __is_initialized = True def handler ( self , func : Callable , return_async = False ) -> Callable : \"\"\"Register a function as a handler. If `bool(return_async) == False`, all subscribers will be treated as non-synchronous. Args: func (Callable): Callable as a Desuko handler return_async (bool): Should the function return an asyncronious Callable Returns: Callable: Registred function \"\"\" if func . __name__ . startswith ( '_' ): func_name = func . __name__ [ 1 :] else : func_name = func . __name__ key = f ' { func . __module__ } . { func_name } ' is_func_async = inspect . iscoroutinefunction ( func ) def handle_subscribers ( * args , ** kwargs ): \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ]: if is_sub_async : logger . warning ( ' %s . %s is an asyncronious function, that was registered as synchronous.' , subscriber . __module__ , subscriber . __name__ , ) subscriber ( * args , ** kwargs ) return result async def async_handle_subscribers ( * args , ** kwargs ): \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" if is_func_async : result = await func ( * args , ** kwargs ) else : result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ]: if is_sub_async : await subscriber ( * args , ** kwargs ) else : subscriber ( * args , ** kwargs ) return result self . __registered_handlers [ key ] = set () logger . info ( 'Handler added: %s ' , key ) return async_handle_subscribers if return_async else handle_subscribers def subscribe ( self , handler : str , func : Callable ) -> None : \"\"\"Return a function to register a subscriber. Args: handler (str): Handler import path func (Callable): Function to add as a subscriber Raises: ValueError: Provided invalid handler \"\"\" try : self . __registered_handlers [ handler ] . add (( func , inspect . iscoroutinefunction ( func ))) except KeyError as exc : raise ValueError ( f ' { exc . args [ 0 ] } is not a valid handler.' ) from exc logger . info ( 'Subscriber added: %s . %s -> %s ' , func . __module__ , func . __name__ , handler )","title":"Module desuko.loader"},{"location":"reference/desuko/loader/#variables","text":"logger","title":"Variables"},{"location":"reference/desuko/loader/#classes","text":"","title":"Classes"},{"location":"reference/desuko/loader/#loader","text":"class Loader ( create_group_def : Callable , modules : dict ) View Source class Loader : \"\"\"Post loader of Desuko modules.\"\"\" def __init__ ( self , create_group_def : Callable , modules : dict ) : \"\"\"Initialize a loader. Args: create_group_def (Callable): `Bot.create_group` function modules (dict): Loaded modules \"\"\" self . __create_group_def = create_group_def self . __modules = modules if modules else {} self . __registered_handlers = {} self . __is_initialized = False self . shared_memory = {} def init_modules ( self ) -> None : \"\"\"Initialize the provided modules.\"\"\" if self . __is_initialized : logger . warning ( 'Attempt to initialize modules twice.' ) return for module_name , module in self . __modules . items () : discord_module_name = '' . join ( i for i in module_name if i . isalpha ()) [ :32 ] if not discord_module_name : logger . warning ( '%s was SKIPPED. (Reason: Invalid __NAME__ value)' , module [ 'import_path' ] , ) continue module_cmd_group = self . __create_group_def ( discord_module_name , module [ 'desc' ] ) module [ 'class' ] ( self , module_cmd_group , module [ 'config' ] ) self . __is_initialized = True def handler ( self , func : Callable , return_async = False ) -> Callable : \"\"\"Register a function as a handler. If `bool(return_async) == False`, all subscribers will be treated as non-synchronous. Args: func (Callable): Callable as a Desuko handler return_async (bool): Should the function return an asyncronious Callable Returns: Callable: Registred function \"\"\" if func . __name__ . startswith ( '_' ) : func_name = func . __name__ [ 1: ] else : func_name = func . __name__ key = f '{func.__module__}.{func_name}' is_func_async = inspect . iscoroutinefunction ( func ) def handle_subscribers ( * args , ** kwargs ) : \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ] : if is_sub_async : logger . warning ( '%s.%s is an asyncronious function, that was registered as synchronous.' , subscriber . __module__ , subscriber . __name__ , ) subscriber ( * args , ** kwargs ) return result async def async_handle_subscribers ( * args , ** kwargs ) : \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" if is_func_async : result = await func ( * args , ** kwargs ) else : result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ] : if is_sub_async : await subscriber ( * args , ** kwargs ) else : subscriber ( * args , ** kwargs ) return result self . __registered_handlers [ key ] = set () logger . info ( 'Handler added: %s' , key ) return async_handle_subscribers if return_async else handle_subscribers def subscribe ( self , handler : str , func : Callable ) -> None : \"\"\"Return a function to register a subscriber. Args: handler (str): Handler import path func (Callable): Function to add as a subscriber Raises: ValueError: Provided invalid handler \"\"\" try : self . __registered_handlers [ handler ] . add (( func , inspect . iscoroutinefunction ( func ))) except KeyError as exc : raise ValueError ( f '{exc.args[0]} is not a valid handler.' ) from exc logger . info ( 'Subscriber added: %s.%s -> %s' , func . __module__ , func . __name__ , handler )","title":"Loader"},{"location":"reference/desuko/loader/#methods","text":"","title":"Methods"},{"location":"reference/desuko/loader/#handler","text":"def handler ( self , func : Callable , return_async = False ) -> Callable Register a function as a handler. If bool(return_async) == False , all subscribers will be treated as non-synchronous. Parameters: Name Type Description Default func Callable Callable as a Desuko handler None return_async bool Should the function return an asyncronious Callable None Returns: Type Description Callable Registred function View Source def handler ( self , func : Callable , return_async = False ) -> Callable : \"\"\"Register a function as a handler. If `bool(return_async) == False`, all subscribers will be treated as non-synchronous. Args: func (Callable): Callable as a Desuko handler return_async (bool): Should the function return an asyncronious Callable Returns: Callable: Registred function \"\"\" if func . __name__ . startswith ( '_' ) : func_name = func . __name__ [ 1: ] else : func_name = func . __name__ key = f '{func.__module__}.{func_name}' is_func_async = inspect . iscoroutinefunction ( func ) def handle_subscribers ( * args , ** kwargs ) : \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ] : if is_sub_async : logger . warning ( '%s.%s is an asyncronious function, that was registered as synchronous.' , subscriber . __module__ , subscriber . __name__ , ) subscriber ( * args , ** kwargs ) return result async def async_handle_subscribers ( * args , ** kwargs ) : \"\"\"Call the provided function and its subscribers. Args: args (Iterable): Arguments kwargs (dict): Keyword arguments Returns: Any: Any result from the provided function (NOT its subscribers) \"\"\" if is_func_async : result = await func ( * args , ** kwargs ) else : result = func ( * args , ** kwargs ) for subscriber , is_sub_async in self . __registered_handlers [ key ] : if is_sub_async : await subscriber ( * args , ** kwargs ) else : subscriber ( * args , ** kwargs ) return result self . __registered_handlers [ key ] = set () logger . info ( 'Handler added: %s' , key ) return async_handle_subscribers if return_async else handle_subscribers","title":"handler"},{"location":"reference/desuko/loader/#init_modules","text":"def init_modules ( self ) -> None Initialize the provided modules. View Source def init_modules ( self ) -> None : \"\"\"Initialize the provided modules.\"\"\" if self . __is_initialized : logger . warning ( 'Attempt to initialize modules twice.' ) return for module_name , module in self . __modules . items () : discord_module_name = '' . join ( i for i in module_name if i . isalpha ())[ : 32 ] if not discord_module_name : logger . warning ( '%s was SKIPPED. (Reason: Invalid __NAME__ value)' , module [ 'import_path' ], ) continue module_cmd_group = self . __create_group_def ( discord_module_name , module [ 'desc' ]) module [ 'class' ]( self , module_cmd_group , module [ 'config' ]) self . __is_initialized = True","title":"init_modules"},{"location":"reference/desuko/loader/#subscribe","text":"def subscribe ( self , handler : str , func : Callable ) -> None Return a function to register a subscriber. Parameters: Name Type Description Default handler str Handler import path None func Callable Function to add as a subscriber None Raises: Type Description ValueError Provided invalid handler View Source def subscribe ( self , handler : str , func : Callable ) -> None : \"\"\"Return a function to register a subscriber. Args: handler (str): Handler import path func (Callable): Function to add as a subscriber Raises: ValueError: Provided invalid handler \"\"\" try : self . __registered_handlers [ handler ] . add (( func , inspect . iscoroutinefunction ( func ))) except KeyError as exc : raise ValueError ( f ' { exc . args [ 0 ] } is not a valid handler.' ) from exc logger . info ( 'Subscriber added: %s . %s -> %s ' , func . __module__ , func . __name__ , handler )","title":"subscribe"}]}